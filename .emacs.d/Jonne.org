The following is the latest revision of my Emacs configuration which
has grown spontaneously over the past decades. I've borrowed several parts
from others' configurations, too many to properly give credit to here,
and frankly, in almost all cases, I don't remember where I first found the
code. Nevertheless, thanks to the original authors!

(For simplicity I've renamed all functions to have the same the
~jms/~-prefix, regardless of who wrote it originally.)

* Personal info

#+BEGIN_SRC emacs-lisp
    (setq user-full-name "Jonne Mickelin SÃ¤therblom")
#+END_SRC

* Emacs initialization
** Directories
The directory where ~package.el~ stores installed packages.
#+BEGIN_SRC emacs-lisp
  (setq package-user-dir (expand-file-name "elpa" user-emacs-directory))
#+END_SRC

Packages not handled through ~package.el~ are stored here.
#+BEGIN_SRC emacs-lisp
  (setq jms/lib-directory (expand-file-name "lib" user-emacs-directory))
  (when (not (file-exists-p jms/lib-directory))
    (make-directory jms/lib-directory))
#+END_SRC

Caches and similar go here.
#+BEGIN_SRC emacs-lisp
  (setq jms/var-directory (expand-file-name "var" user-emacs-directory))
  (when (not (file-exists-p jms/var-directory))
    (make-directory jms/var-directory))
#+END_SRC

Private settings.
#+BEGIN_SRC emacs-lisp
  (setq jms/private-directory (expand-file-name "private" user-emacs-directory))
#+END_SRC

Snippets for YaSnippet.
#+BEGIN_SRC emacs-lisp
  (setq jms/snippet-directory (expand-file-name "snippets" user-emacs-directory))
#+END_SRC

Backups of files are stored outside the config directory.
#+BEGIN_SRC emacs-lisp
  (setq jms/backup-directory (expand-file-name "~/.backups"))
#+END_SRC

Notes and bookmarks.
#+BEGIN_SRC emacs-lisp
  (setq jms/note-directory (expand-file-name "~/notes"))
#+END_SRC

** Utility functions and macros

#+BEGIN_SRC emacs-lisp
  (defmacro after (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
       '(progn ,@body)))


  (defmacro setappendq (variable &rest entries)
    "Append the contents of ENTRIES to the variable VARIABLE.
  If VARIABLE is undefined, it is treated as being nil."
    `(let ((initial (if (boundp (quote ,variable))
                        ,variable
                      nil)))
       (setq ,variable
             (append initial
                     ,@entries))))
#+END_SRC

We use functions from ~cl~ throughout the configuration.
#+BEGIN_SRC emacs-lisp
  (require 'cl-lib)
  (require 'cl-extra)
#+END_SRC

** Package sources

#+BEGIN_SRC emacs-lisp
  (setq package-archives
        '(("gnu" . "http://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

** Loading packages

Provide a way to disable ~use-package~'s ~:ensure~, so that
installation of packages can be done externally to Emacs. This can be
done in two ways:

1. Through the environment variable
   ~EMACS_USE_PACKAGE_INHIBIT_ENSURE~. A value of ~1~ means that
   ~use-package~ should ignore the value of ~:ensure~, and never use
   ~package.el~ to install packages even to install packages. A value
   of ~0~ means that ~use-package~ _should_ consider the value of
   ~:ensure~, and use it to determine whether to install packages.

2. Otherwise, if Emacs was invoked by calling a package in the Nix
   store, indicating that Emacs is likely installed through Nix, the
   default behavior is to ignore ~:ensure~.

3. On non-Nix systems, the default behavior is reversed, defaulting to
   ~:ensure~ being considered.

#+BEGIN_SRC emacs-lisp
  (setq jms/use-package-inhibit-ensure
	(let ((env (getenv "EMACS_USE_PACKAGE_INHIBIT_ENSURE")))
	  (cond
	   ((string= env "0") nil)
	   ((string= env "1") t)
	   ((string-prefix-p "/nix/store/" (invocation-directory)))
	   (t nil))))

  (setq use-package-ensure-function
	(lambda (name args _state)
	  (if jms/use-package-inhibit-ensure
	      nil
	    (use-package-ensure-elpa name args _state))))

  ; Fail early if package is not found, prompting the user make sure it
  ; is installed externally. Deferring this would hide the problem.
  (setq use-package-always-demand t)
#+END_SRC

This sets up the load path so that we can override it
#+BEGIN_SRC emacs-lisp
  (package-initialize)
#+END_SRC

Add every subdirectory of ~jms/lib-directory~ to the load path.
#+BEGIN_SRC emacs-lisp
  (let ((default-directory jms/lib-directory))
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

Also add the directory itself:
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path jms/lib-directory)
#+END_SRC

Any site-local or similarly installed packages go here.
#+BEGIN_SRC emacs-lisp
  ;; symlink to directory holding local install of agda-input.el
  (add-to-list 'load-path (expand-file-name "agda-input" user-emacs-directory))
#+END_SRC

We handle most other packages via the ~use-package~ macro, which
uses ~package.el~ to install missing packages automatically.
Install ~use-package~ if it is missing.
#+BEGIN_SRC emacs-lisp
  (when (not (package-installed-p 'use-package))
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)

  ;; Newer versions of use-package try to catch and handle all loading
  ;; errors itself, breaking any use of ignore-errors that might be
  ;; wrapping it. Disable this behavior.
  (setq use-package-expand-minimally t)
#+END_SRC

** Load private configuration
All sensitive information is stored in a separate file.
#+BEGIN_SRC emacs-lisp
  (let ((sec-file (expand-file-name "emacs-sec.org"
                                    jms/private-directory)))
    (when (file-exists-p sec-file)
      (org-babel-load-file sec-file)))
#+END_SRC

** Don't clutter init.el with Customize crap
Customize defaults to writing its configuration to the init file.
Previously I just avoided using Customize, but newer versions of
=Package.el= saves its list of explicitly installed packages using
customize, meaning it clutters the file constantly. For this reason,
we save it in a separate file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el"
                                      user-emacs-directory))
  ;; package-autoremove uses custom variables set automatically to
  ;; determine orphaned packages, so load it to avoid problems, even
  ;; though we are unlikely to want anything else set by customize.
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Tramp security
Prevent tramp-sudo from saving the password in plaintext in
=~/.authinfo= or =~/.netrc=.
#+BEGIN_SRC emacs-lisp
  (setq auth-source-save-behavior nil)
#+END_SRC

Change the password cache expiry to 60 minutes.
#+BEGIN_SRC emacs-lisp
  (setq password-cache-expiry 3600)
#+END_SRC

* General configuration
** Startup
Improve the startup speed.
#+BEGIN_SRC emacs-lisp
  (modify-frame-parameters nil '((wait-for-wm . nil)))
#+END_SRC

Don't show the welcome message.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

Use ~org-mode~ for the scratch buffer. Also add a keybinding
to quickly (re)open the scratch buffer.
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode
        initial-scratch-message "")

  (defun jms/create-scratch-buffer nil
     "Jump to the scratch buffer and create one if it doesn't exist."
     (interactive)
     (switch-to-buffer (get-buffer-create "*scratch*"))
     (org-mode))
  (bind-key "C-x p" 'jms/create-scratch-buffer)
#+END_SRC
** Backup

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        (list (cons "." jms/backup-directory)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq auto-save-list-file-prefix (expand-file-name "auto-save-list/.saves-"
                                                     jms/var-directory))
  (setq tramp-allow-unsafe-temporary-files t) ;; Inhibit prompt when editing root-owned files with sudo: or su:
#+END_SRC

Don't create backups of sensitive files!
  #+BEGIN_SRC emacs-lisp
      (defvar jms/backup-ignore-regexps (list "^/dev/shm/pass.*" ; pass creates files here
                                             "\\.gpg$")
        "*List of filename regexps to not backup")

      (defvar jms/backup-ignore-tramp-methods (list "su"
                                                    "sudo")
        "*List of tramp remote methods to not backup")

      (defun jms/backup-enable-p (name)
        "Filter certain file backups"
        (and (normal-backup-enable-predicate name)
             (not (member (file-remote-p name 'method)
                          jms/backup-ignore-tramp-methods))
             (cl-notany (lambda (re) (string-match-p re name))
                        jms/backup-ignore-regexps)))

    (setq backup-enable-predicate 'jms/backup-enable-p)
#+END_SRC

** Path
The following package inherits the ~PATH~ and ~MANPATH~ environment
variables from the login shell.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
      :ensure t
      :init (exec-path-from-shell-initialize))
#+END_SRC


** Encryption
Add
#+BEGIN_SRC text
  epa-file-enctypt-to: ; epa-file-cache-passphrase-for-symmetric-encryption: t
#+END_SRC
as file local variables to use symmetric encryption, and
#+BEGIN_SRC text
  epa-file-encrypt-to: ("email@example.com")
#+END_SRC
for asymmetric.

#+BEGIN_SRC emacs-lisp
  (require 'epa-file)
  (epa-file-enable)
#+END_SRC

** Amx
Amx provides alternative completion systems for e.g. ~M-x~,
such as ido.
#+BEGIN_SRC emacs-lisp
  (use-package amx
    :ensure t
    :config (amx-mode t))
#+END_SRC

** Reenable disabled commands
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC

** Don't ask to reload TAGS files

#+BEGIN_SRC emacs-lisp
  (setq tags-revert-without-query t)
#+END_SRC

* Behaviour
** Faster tramp remote editing

#+BEGIN_SRC emacs-lisp
  (setq remote-file-name-inhibit-cache t)
  (setq remote-file-name-inhibit-locks t)
  (setq tramp-verbose 1)
#+END_SRC

** Faster keyecho for commands
#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

** Prompt before closing.
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

** Show hints for some commmands that require several key presses
#+BEGIN_SRC emacs-lisp
  (defun jms/which-key-automatically-for-prefixes (key-desc _)
    (cond
     ;; Automatically pop up which-key immediately for these prefixes.
     ;; For other prefixes, which-key can be invoked by pressing C-h.
     ;; While which-key is showing, pressing C-h h calls `help-char',
     ;; which is the Emacs default behavior.
     ((string-match-p "^C-x r" key-desc) nil)
     ((string-match-p "^C-x 4" key-desc) nil)
     ((string-match-p "^C-x 8" key-desc) nil)
     ((string-match-p "^C-x x" key-desc) nil)
     ((string-match-p "^C-c p" key-desc) nil)
     ((string-match-p "^C-c s" key-desc) nil)
     (t (if (which-key--popup-showing-p)
            nil
          10000))))

  (use-package which-key
    :ensure t
    :config (progn

              ;; This breaks the display of the currently entered prefix
              ;; in the modeline, for whatever reason. Furthermore,
              ;; which-key-show-early-on-C-h does not work for delays
              ;; created by delay-functions...
              ;;
              ;; (add-hook 'which-key-delay-functions #'jms/which-key-automatically-for-prefixes)

              (setq
               ;; Press C-h to manually invoke which-key
               which-key-show-early-on-C-h t

               ;; Set artificially high to avoid starting it automatically
               which-key-idle-delay 10000

               ;; After invoking it manually, we want sub-menus to show
               ;; up almost instantly, however.
               which-key-idle-secondary-delay 0.05

               which-key-popup-type 'side-window
               which-key-side-window-location 'bottom

               ;; which-key tends to allocate too little space without
               ;; this, causing the last row to be nearly invisible
               which-key-allow-imprecise-window-fit nil

               which-key-show-prefix 'minibuffer
               which-key-add-column-padding 3)

              (which-key-mode)))
#+END_SRC

** Disable some default keybindings
I dislike the arrow keys.
#+BEGIN_SRC emacs-lisp
  (unbind-key "<left>")
  (unbind-key "<right>")
  (unbind-key "<up>")
  (unbind-key "<down>")
#+END_SRC

This often trips me up when using my WM (which binds ~s-l~).
#+BEGIN_SRC emacs-lisp
  (unbind-key "M-l")
#+END_SRC

** Use C-SPC to repeat mark popping after initial C-u C-SPC

#+BEGIN_SRC emacs-lisp
  (setq set-mark-command-repeat-pop t)
#+END_SRC

** Sideline mode

#+BEGIN_SRC emacs-lisp
  (use-package sideline
    :ensure t
    :config (setq sideline-force-display-if-exceeds t))
#+END_SRC

* Buffers
** Ibuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
      :bind ("C-x C-b" . ibuffer))

  (use-package ibuf-ext
    :requires ibuffer)

  (use-package ibuffer-project
    :ensure t
    :requires ibuffer
    :config
    (defun jms/ibuffer-init ()
      "Set up the filter groups."

      (ibuffer-auto-mode)

      (setq ibuffer-filter-groups
            (append jms/ibuffer-filter-groups
                    (ibuffer-project-generate-filter-groups)))

      (unless (eq ibuffer-sorting-mode 'project-file-relative)
        (ibuffer-do-sort-by-project-file-relative)))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Change the ordering of the filter groups. This must be done as an ;;
    ;; advice, since the ordering in ibuffer-filter-groups also defines  ;;
    ;; precedence of the tests. Furthermore, ibuffer-redisplay-engine    ;;
    ;; reverses the list of groups returned by                           ;;
    ;; ibuffer-generate-filter-groups, so we need to compute the reverse ;;
    ;; ordering.                                                         ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    (defun jms/ibuffer-sort-precedence (group-name)
      "Returns the precedence of a group given it's name. The lower the
       precedence, the higher the position. Groups that match no
       predicate is given default precedence of 45."
      (cond ((string-match (concat "^Project:") group-name) 10)
            ((string= "Default" group-name) 40)
            ((string= "Latex" group-name) 50)
            ((string= "*buffers*" group-name) 9999)
            (t 45)))

    (defadvice ibuffer-generate-filter-groups (after reverse-ibuffer-groups ()
                                                activate)
      "Transform the result returned by `ibuffer-generate-filter-groups'
      to reorder the groups according to the precedences defined in
      jms/ibuffer-sort-precedence. Groups with the same precedence are
      ordered alphabetically."
      (setq ad-return-value
            (nreverse (sort ad-return-value
                            (lambda (a b)
                              (let* ((id1 (car a))
                                     (id2 (car b))
                                     (precedence1  (jms/ibuffer-sort-precedence id1))
                                     (precedence2  (jms/ibuffer-sort-precedence id2)))
                                (if (= precedence1 precedence2)
                                    (string< id1 id2)
                                  (< precedence1 precedence2))))))))

    (add-to-list 'ibuffer-project-root-functions
                 '((lambda (dir)
                     (replace-regexp-in-string
                      ;; Shorten long nix store paths (include 6 chacters
                      ;; of the hash)
                      "^\\(/nix/store/......\\).*?\\(-.*\\)$"
                      "\\1...\\2"
                      dir)) . "Directory"))
    (ibuffer-project-clear-cache)

    (setq
     jms/ibuffer-filter-groups
     '(;; List buffers named `*<name>*' in a separate heading.
       ("*buffers*" (name . "^\\*.*\\*")))

     ;; `ibuffer-project-generate-filter-groups' does not check whether
     ;; a buffer would be moved to a dedicated group such as the ones in
     ;; `jms/ibuffer-filter-groups'. We set this to nil to ensure that
     ;; groups left empty are hidden.
     ibuffer-show-empty-filter-groups nil

     ibuffer-project-use-cache t

     ;; Add a column for the filename relative to project root.
     ;; Remove the column for size.
     ibuffer-formats
     '((mark modified read-only " "
             (name 25 25 :left :elide)
             " "
             (mode 14 14 :left :elide)
             " "
             project-file-relative)))

    :hook (ibuffer . jms/ibuffer-init))
#+END_SRC

** Uniquify

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :init (setq uniquify-buffer-name-style 'post-forward
                uniquify-separator ":"))
#+END_SRC

* Files and directories
** Neotree

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :bind ("C-M-Ã¥" . neotree-toggle))
#+END_SRC

** Dired

#+BEGIN_SRC emacs-lisp
  (use-package dired-x
      :init (add-hook 'dired-load-hook (lambda ()
                                         (load "dired-x"))))

  (defun jms/dired-init ()
    ;; Dired mixes normal files and dotfiles. Since I couldn't figure
    ;; out how to fix this, we count dotfiles as boring.
    (dired-omit-mode 1)
    (setq dired-omit-files (concat dired-omit-files "\\|^\\.[^\\.]+$"))

    ;; Sort directories first, then by by extension.
    (setq dired-listing-switches "-lGh --group-directories-first"))

  (add-hook 'dired-load-hook #'jms/dired-init)
#+END_SRC

** vcsh
In order to use Magit for repos handled by =vcsh=, the following Tramp trick can be used:

#+BEGIN_SRC emacs-lisp
  (after 'tramp
    (add-to-list 'tramp-methods
                 '("vcsh"
                   (tramp-login-program "vcsh")
                   (tramp-login-args (("enter") ("%h")))
                   (tramp-remote-shell "/bin/sh")
                   (tramp-remote-shell-args ("-c"))
                   ;; Force use of a Bourne-compatible shell
                   (tramp-login-env (("SHELL") ("/bin/bash"))))))
#+END_SRC

Now, you can edit a dotfile and access it for version control through Magit by navigating to it with e.g.
=C-x C-f /vcsh:emacs:.emacs.d/Jonne.el=.

* Ido and Helm
I use ido for most interaction with files and buffers, and Helm selectively
for some other things.

#+BEGIN_SRC emacs-lisp
  (ido-mode t)

  (after 'magit
    (defun bind-ido-magit ()
      (define-key ido-common-completion-map
                  (kbd "C-M-g") 'ido-enter-magit-status))

    (add-hook 'ido-setup-hook 'bind-ido-magit))

  (defun bind-ido-keys ()
    (define-key ido-completion-map (kbd "C-n") 'ido-next-match)
    (define-key ido-completion-map (kbd "C-p") 'ido-prev-match))

  (add-hook 'ido-setup-hook 'bind-ido-keys)

  (setq ido-enable-flex-matching t
        ido-case-fold t
        ; Ony ignore . and ..
        ido-ignore-files '("\\`\\.\\./" "\\`\\./")
        ido-ignore-directories '("\\`\\.\\./" "\\`\\./")
        ido-max-work-file-list 30
        ido-save-directory-list-file (expand-file-name
                                      "ido.last"
                                      jms/var-directory))
#+END_SRC

Because backing out of deeply nested =vcsh= directories (such as the
one entered with =dotemacs=) is annoying, here is a command for
replacing the directory shown in =ido= with the home directory.
#+BEGIN_SRC emacs-lisp
  (defun jms/ido-home ()
    (interactive)
    (ido-set-current-home)
    (setq ido-exit 'refresh)
    (setq ido-rotate-temp t)
    (exit-minibuffer))

  (define-key ido-file-completion-map (kbd "C-M-h") #'jms/ido-home)
#+END_SRC

Ido completion for imenu.
#+BEGIN_SRC emacs-lisp
  (use-package idomenu
      :ensure idomenu
      :bind ("C-M-i" . idomenu))
#+END_SRC

Show the list of possible completions vertically.

#+BEGIN_SRC emacs-lisp
  ; This is broken with multiple frames on newer versions of Emacs
  (use-package ido-vertical-mode
      :ensure t
      :disabled t
      :init (progn
              (setq ido-vertical-define-keys t)
              (ido-vertical-mode t)))
#+END_SRC

Use ido /everywhere/.
#+BEGIN_SRC emacs-lisp
  (ido-everywhere t)

  (use-package ido-completing-read+
    :ensure t
    :init (setq ido-ubiquitous-mode t))
#+END_SRC

To enable Helm everywhere, use ~(helm-mode 1)~. I don't do this.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :init (setq helm-move-to-line-cycle-in-source t))
#+END_SRC

* Hydra
#+BEGIN_SRC emacs-lisp
  (use-package major-mode-hydra
    :ensure t
    :bind ("C-c C-SPC" . major-mode-hydra))
#+END_SRC

* Input method
Use ~agda-mode~'s input method to type various unicode symbols.
Rebind the default Agda prefix to ~Â§~ in order to not interfere with
programming.
#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (use-package agda-input
      :config (progn
                (defadvice switch-to-buffer (after activate-input-method activate)
                  (activate-input-method "Agda"))


                (setq agda-input-tweak-all '(agda-input-compose
                                             (agda-input-prepend "Â§")
                                             (agda-input-nonempty)))
                (setq agda-input-user-translations '(("Â§" "Â§")))
                ;; Make the settings have effect. Needed since we are not using
                ;; customize.
                (agda-input-setup))))
#+END_SRC

* Locale and encoding
** Weeks start on mondays

#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1
        calendar-day-name-array ["SÃ¶ndag" "MÃ¥ndag" "Tisdag" "Onsdag"
                                          "Torsdag" "Fredag" "LÃ¶rdag"]
        calendar-month-name-array ["Januari" "Februari" "Mars" "April" "Maj"
                                             "Juni" "Juli" "Augusti" "September"
                                             "Oktober" "November" "December"])

#+END_SRC

** Use UTF-8 for everything

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
#+END_SRC

** Never use tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Do not use double spaces ever
This helps fix problems with filling and sentence-based movement
commands.
#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil
        colon-double-space        nil)
#+END_SRC

* History
** Save history
#+BEGIN_SRC emacs-lisp
  (setq history-length 250)
#+END_SRC

** Open recent files

#+BEGIN_SRC emacs-lisp
  (require 'recentf)
  ;; Remember to set the save file *before* enabling recentf-mode,
  ;; otherwise the file list will be loaded using the default file.
  (setq recentf-save-file (expand-file-name "recentf" jms/var-directory))
  (recentf-mode t)
  (setq recentf-max-saved-items 50)
  (run-at-time "1 min" 60
               #'(lambda ()
                   (let ((inhibit-message t))
                     (recentf-save-list))))

  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))
  (bind-key "C-x C-r" 'ido-recentf-open)
#+END_SRC

** Save place in files

#+BEGIN_SRC emacs-lisp
  (require 'saveplace)
  (setq-default save-place t)
  (setq save-place-file (expand-file-name "places" jms/var-directory))
#+END_SRC


* Privacy
** Clear the kill ring

#+BEGIN_SRC emacs-lisp
  (defun clear-kill-ring ()
    (interactive)
    (setq kill-ring nil))
#+END_SRC

* Files
** Find files in the current repository

#+BEGIN_SRC emacs-lisp
  (use-package find-file-in-repository
      :ensure find-file-in-repository
      :bind ("C-x C-g" . find-file-in-repository))
#+END_SRC

** Inhibit the "symlink to version-controlled source-file" warning

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

** Delete trailing whitespace and append a newline

We might not want to do this when the file is under version control
(if the other maintainers are not as conscious about whitespace
trimming), so the following predicate checks this:

#+BEGIN_SRC emacs-lisp
  (defun jms/file-under-version-control-p ()
    (and (fboundp 'magit-file-tracked-p)
         (magit-file-tracked-p buffer-file-name)))
#+END_SRC

Override this behavior by toggling the following variable in e.g.
~.dir-locals.el~. The default behavior is to trim.
#+BEGIN_SRC emacs-lisp
  (setq jms/trim-all-files t)
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (add-hook 'find-file-hook #'(lambda ()
                                (when (and (jms/file-under-version-control-p)
                                           (not jms/trim-all-files))
                                  (setq mode-require-final-newline nil))))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (defun jms/before-save-hook ()
    (unless
        (and (jms/file-under-version-control-p)
             (not jms/trim-all-files))
      (delete-trailing-whitespace)))

  (add-hook 'before-save-hook #'jms/before-save-hook)
#+END_SRC

** Write time stamps when saving files
For things not under version control.

Add the following template near the top of a file:
#+BEGIN_SRC text
  Time-stamp: <>
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq time-stamp-format "%f %:y-%02m-%02d %02H:%02M:%02S %U")
  (add-hook 'write-file-hooks 'time-stamp)
#+END_SRC

** Quickly open config file

Set the following variable to =1= if using =vcsh= to handle Emacs's
dotfiles on the current machine.
#+BEGIN_SRC emacs-lisp
  (setq jms/dot-emacs-through-vcsh (string= (getenv "EMACS_CONFIG_IN_VCSH") "1"))
   #+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun dotemacs ()
    (interactive)
    (let ((org-file (if jms/dot-emacs-through-vcsh
                        (format "%s%s" "/vcsh:emacs:" jms/emacs-init-org-file)
                      jms/emacs-init-org-file)))
      (find-file org-file)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun nixos-conf ()
    (interactive)
    (find-file (format "~/src/nixos-cfg/%s/" (system-name))))
#+END_SRC

* Movement and editing
** Avy
Quickly jump within documents.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("C-Ã¶" . avy-goto-char-timer)
           ("C-x C-Ã¶" . avy-goto-line))
    :config (setq avy-keys '(?q ?w ?e ?r ?a ?s ?d ?f)
                  avy-style 'at))
#+END_SRC
** Ace-window

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :bind ("M-Ã¶" . ace-window)
    :config (setq aw-keys '(?q ?w ?e ?r ?a ?s ?d ?f)))
#+END_SRC

** Edit comments in separate windows

#+BEGIN_SRC emacs-lisp
  (use-package separedit
    :ensure t
    :bind (:map prog-mode-map
           ("C-c '" . #'separedit))
    :config (progn
              (setq separedit-default-mode 'markdown-mode)
              ;; Needed to support Haddock comments
              (add-to-list 'separedit-not-support-docstring-modes 'haskell-mode)))
#+END_SRC

** Display indications when scrolling in buffer or undoing/yanking

Beacon displays a quickly fading highlight at cursor when window scrolls.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config (progn
              (setq beacon-color "#97af47")
              (beacon-mode)))
#+END_SRC

Colour the background of yanked or undone text until next command.

#+BEGIN_SRC emacs-lisp
  (use-package volatile-highlights
    :ensure t
    :config (volatile-highlights-mode))
#+END_SRC

** Dump Jump

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :bind (:map dumb-jump-mode-map
           ("C-M-." . dump-jump-go-other-window)
           ("M-." . dumb-jump-go)
           ("M-," . dumb-jump-back)
           ("C-c M-." . dumb-jump-quick-look)
           ("M-i". dumb-jump-go-prompt))
    :init (progn
            (dumb-jump-mode t)
            (setq dumb-jump-force-searcher 'ag)
            (setq xref-backend-functions (remq 'etags--xref-backend xref-backend-functions)) ; Remove TAGS
            (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
            (unbind-key "C-M-g" dumb-jump-mode-map)
            (unbind-key "C-M-p" dumb-jump-mode-map)
            (unbind-key "C-M-q" dumb-jump-mode-map)))
#+END_SRC

** Highlight symbol under cursor

#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
    :ensure t
    :config (progn
              (setq highlight-symbol-idle-delay 0.1
                    highlight-symbol-on-navigation-p t)
              (add-hook 'prog-mode-hook #'jms/enable-highlight-symbol-mode)
              (add-hook 'text-mode-hook #'jms/enable-highlight-symbol-mode)
              (bind-key "M-'" 'highlight-symbol-query-replace highlight-symbol-nav-mode-map)))

  (defun jms/enable-highlight-symbol-mode ()
    (highlight-symbol-mode t)
    (highlight-symbol-nav-mode t))
#+END_SRC

** Smart scan
#+BEGIN_SRC emacs-lisp
  (use-package smartscan
    :ensure t
    :bind (:map smartscan-map
                ("M-n" . smartscan-symbol-go-forward)
                ("M-p" . smartscan-symbol-go-backward))
    :hook (prog-mode . smartscan-mode))
#+END_SRC

** Tab-completion
If line is already indented, try to complete.

#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

** Autocompletion
Set up autocompletion, and use the usual keybindings in the
completion list.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :bind (:map company-mode-map
           ([remap completion-at-point] . company-complete)
           ([remap complete-symbol] . company-complete)
           :map company-active-map
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous)
           ("C-m" . company-complete))
    :init (global-company-mode)
    :config (setq company-minimum-prefix-length 3
                  company-idle-delay 0.0))

  (use-package company-quickhelp
    :ensure t
    :hook (global-company-mode . company-quickhelp-mode)
    :init (setq company-quickhelp-delay 0))

  (use-package company-box
    :ensure t
    :hook (global-company-mode . company-box-mode))
#+END_SRC

Alternatively, use ~ido-at-point~ for ~ido~-like matching.
#+BEGIN_SRC emacs-lisp
  (use-package ido-at-point
      :ensure t
      :disabled t
      :init (ido-at-point-mode))
#+END_SRC

** Put the name of the current file in the kill ring.

#+BEGIN_SRC emacs-lisp
  (defun copy-file-name-to-kill-ring ()
    "Copy the current buffer file name to the kill ring."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the kill ring." filename))))
#+END_SRC

** Prompt for a file (with completion) and insert the result

#+BEGIN_SRC emacs-lisp
  (defun jms/insert-file-name (filename &optional args)
    "Insert name of file FILENAME into buffer after point.

    Prefixed with \\[universal-argument], expand the file name to
    its fully canocalized path.  See `expand-file-name'.

    Prefixed with \\[negative-argument], use relative path to file
    name from current directory, `default-directory'.  See
    `file-relative-name'.

    The default with no prefix is to insert the file name exactly as
    it appears in the minibuffer prompt."
    ;; Based on insert-file in Emacs -- ashawley 20080926
    (interactive "*fInsert file name: \nP")
    (cond ((eq '- args)
           (insert (file-relative-name filename)))
          ((not (null args))
           (insert (expand-file-name filename)))
          (t
           (insert filename))))

  (bind-key "C-c i" 'jms/insert-file-name)
#+END_SRC

** Expand-region

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
      :ensure t
      :bind ("C-'" . er/expand-region))
#+END_SRC

** Electric parentheses
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t)

  (setq electric-pair-preserve-balance t
        electric-pair-open-newline-between-pairs nil
        electric-pair-inhibit-predicate 'electric-pair-default-inhibit
        electric-pair-skip-whitespace nil)
#+END_SRC

** Multiple cursors

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
      :ensure t
      :bind (("M-Ã¤" . mc/mark-all-dwim)
             ("M-Ã" . mc/edit-beginnings-of-lines)
             ("C-Ã¥" . mc/mark-previous-like-this)
             ("C-Ã" . mc/unmark-previous-like-this)
             ("C-Ã¤" . mc/mark-next-like-this)
             ("C-Ã" . mc/unmark-next-like-this)
             ("C-M-Ã¤" . mc/mark-all-symbols-like-this-in-defun)
             ("M-Ã¥" . mc/mark-all-in-region)

             ("C-S-<mouse-1>" . mc/add-cursor-on-click)

             :map mc/keymap ;; Removes the binding that makes return
                            ;; quit multiple-cursors-mode, thus allowing
                            ;; for insertion of newlines
             ("<return>" . nil)))
#+END_SRC

** iedit

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t)
#+END_SRC

** Indent regions

Invoke =indent-rigidly= with =C-x TAB=.
#+BEGIN_SRC emacs-lisp
  (unbind-key "S-<right>" indent-rigidly-map)
  (unbind-key "S-<left>" indent-rigidly-map)
  (unbind-key "<left>" indent-rigidly-map)
  (unbind-key "<right>" indent-rigidly-map)

  (bind-key "C-M-f" 'indent-rigidly-right-to-tab-stop indent-rigidly-map)
  (bind-key "C-M-b" 'indent-rigidly-left-to-tab-stop indent-rigidly-map)
  (bind-key "C-f" 'indent-rigidly-right indent-rigidly-map)
  (bind-key "C-b" 'indent-rigidly-left indent-rigidly-map)
#+END_SRC

** Spelling

#+BEGIN_SRC emacs-lisp
  (setq ispell-process-directory (expand-file-name "~/")
        ispell-program-name "hunspell"
        flyspell-issue-message-flag nil
        ispell-dictionary "english")

  (dolist (hook '(text-mode-hook))
    (add-hook hook #'(lambda () (flyspell-mode 1))))

  ;; Use =eval: (ispell-change-dictionary language)= as a file local
  ;; variable to select the correct dictionary automatically.
  (dolist (lang '("svenska" "english"))
    (add-to-list 'safe-local-variable-values `(eval ispell-change-dictionary ,lang)))

  (add-hook 'ispell-change-dictionary-hook #'flyspell-buffer)

  ;; Flyspell overrides this key, for some reason.
  (global-set-key (kbd "M-<tab>") 'completion-at-point)

  (defun jms/flyspell-change-dictionary (lang)
    (interactive "sLanguage: ")
    (ispell-change-dictionary lang)
    (flyspell-buffer))

  (defun jms/flysepll-svenska ()
    (interactive)
    (jms/flyspell-change-dictionary "svenska"))

  (defun jms/flysepll-english ()
    (interactive)
    (jms/flyspell-change-dictionary "english"))

  (define-prefix-command 'spelling-map)
  (global-set-key (kbd "C-c s") 'spelling-map)

  (bind-key "s" 'jms/flysepll-svenska spelling-map)
  (bind-key "e" 'jms/flysepll-english spelling-map)

  ;; easy spell check
  (bind-key "w" 'ispell-word spelling-map)
  (bind-key "a" 'flyspell-mode spelling-map)
  (bind-key "b" 'flyspell-buffer spelling-map)
  (bind-key "p" 'flyspell-check-previous-highlighted-word spelling-map)
  (defun flyspell-check-next-highlighted-word ()
    "Custom function to spell check next highlighted word"
    (interactive)
    (flyspell-goto-next-error)
    (ispell-word))
  (bind-key "n" 'flyspell-check-next-highlighted-word spelling-map)

#+END_SRC

** Indicate end of buffer

#+BEGIN_SRC emacs-lisp
  (use-package vim-empty-lines-mode
    :disabled t
    :ensure t
    :init (global-vim-empty-lines-mode))
#+END_SRC

** Undo
Undo tree.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :init (progn (setq undo-tree-visualizer-diff t
                       undo-tree-auto-save-history nil
                       undo-tree-visualizer-relative-timestamps t
                       undo-tree-enable-undo-in-region nil)
                 (global-undo-tree-mode)))
#+END_SRC

** Killing and yanking
Select entries from the kill ring.
#+BEGIN_SRC emacs-lisp
  (bind-key "C-M-y" 'helm-show-kill-ring)
#+END_SRC

Save clipboard's content into the kill ring before overwriting it
with a kill from within Emacs.
#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC

Delete a line without putting it in the kill-ring:
#+BEGIN_SRC emacs-lisp
  (defun jms/silent-kill-line ()
    (interactive)
    (delete-region (point) (line-end-position)))

  (bind-keys :prefix "C-z"
             :prefix-map c-z-prefix-map
             ("C-k" . jms/silent-kill-line))
#+END_SRC

** Searching
Search for symbol at point using =C-u C-s=.

#+BEGIN_SRC emacs-lisp
  (defun jms/isearch-symbol-with-prefix (p)
    "Like isearch, unless prefix argument is provided.
  With a prefix argument P, isearch for the symbol at point."
    (interactive "P")
    (let ((current-prefix-arg nil))
      (call-interactively
       (if p #'isearch-forward-symbol-at-point
         #'isearch-forward))))

  (global-set-key [remap isearch-forward]
                  #'jms/isearch-symbol-with-prefix)
#+END_SRC

Use =ag= for searching file contents. Follow matching lines in their own buffer when moving in search buffers.
#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t
    :hook (ag-mode . next-error-follow-minor-mode))
#+END_SRC

Do the same for =occur-mode=.
#+BEGIN_SRC emacs-lisp
  (add-hook 'occur-mode-hook 'next-error-follow-minor-mode)
#+END_SRC

This seems to have changed recently in some mode?

#+BEGIN_SRC emacs-lisp
  (setq isearch-case-fold-search t)
#+END_SRC

** Scrolling

#+BEGIN_SRC emacs-lisp
  (setq scroll-error-top-bottom t)
#+END_SRC

** Palimpsest

#+BEGIN_SRC emacs-lisp
  (use-package palimpsest
    :ensure t
    :init  (add-hook 'text-mode-hook 'palimpsest-mode))
#+END_SRC

** Query-replace with anzu-mode
Use =anzu-mode= for improved query-replace behaviour.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :ensure t
    :config (global-anzu-mode)
    :bind (("M-%" . anzu-query-replace)
           ("C-M-%" . anzu-query-replace-regexp)))
#+END_SRC

** Window management

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-'" 'balance-windows)
  (setq window-resize-pixelwise t)
#+END_SRC

Redefine =C-x 1= to just maximize the window, leaving a tiny sliver of
the other windows visible. Use =C-x '= for the usual behavior.
#+BEGIN_SRC emacs-lisp
  (bind-key "C-x 1" 'maximize-window)
  (bind-key "C-x '" 'delete-other-windows)
#+END_SRC

** Yasnippets

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :bind (("C-c C-y" . yas-insert-snippet)
           :map yas-minor-mode-map
           ("C-<return>" . yas-expand))
      :init (progn
              (setq yas-snippet-dirs (list jms/snippet-directory))
              (yas-global-mode 1))
      :config (progn (yas-reload-all)
                (setq yas/prompt-functions '(yas-ido-prompt))))
#+END_SRC

** X selection
By default, ~S-insert~ is bound to the normal yank command, which is
confusing and not consistent with other programs. Rebind it to use
the same method of getting the primary x-selection as mouse-2
does.
#+BEGIN_SRC emacs-lisp
  ;;; Code from /usr/share/emacs/24.3/lisp/mouse.el.gz
  (defun jms/insert-x-selection ()
    (interactive)
    (let ((primary
           (cond
             ((eq (framep (selected-frame)) 'w32)
              ;; MS-Windows emulates PRIMARY in x-get-selection, but not
              ;; in x-get-selection-value (the latter only accesses the
              ;; clipboard).  So try PRIMARY first, in case they selected
              ;; something with the mouse in the current Emacs session.
              (or (x-get-selection 'PRIMARY)
                  (x-get-selection-value)))
             ((fboundp 'x-get-selection-value) ; MS-DOS and X.
              ;; On X, x-get-selection-value supports more formats and
              ;; encodings, so use it in preference to x-get-selection.
              (or (x-get-selection-value)
                  (x-get-selection 'PRIMARY)))
             ;; FIXME: What about xterm-mouse-mode etc.?
             (t
              (x-get-selection 'PRIMARY)))))
      (unless primary
        (error "No selection is available"))
      (push-mark (point))
      (insert primary)))

  (bind-key "S-<insert>" #'jms/insert-x-selection)
#+END_SRC

Make the middle click insert text at point.
#+BEGIN_SRC emacs-lisp
  (setq mouse-yank-at-point t)
#+END_SRC

* Folding
** Outline mode

#+BEGIN_SRC emacs-lisp
  (set-display-table-slot
   standard-display-table
   'selective-display
   (let ((face-offset (* (face-id 'shadow) (lsh 1 22))))
     (vconcat (mapcar (lambda (c) (+ face-offset c)) " [Â·Â·Â·] "))))
#+END_SRC

* Linting and validating
** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init (setq global-flycheck-mode t))
#+END_SRC

** Flymake

#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :ensure t
    :config
    (use-package flymake-cursor
      :ensure t
      :init (setq flymake-cursor-auto-enable t)))
#+END_SRC

* Highlighting
- Use ~C-x w h regexp RET face RET~ to highlight portions of text.
- Use ~C-x w l regexp RET face RET~ to highlight the entire line.
- Use ~C-x w r regexp RET~ to remove a highlight.

#+BEGIN_SRC emacs-lisp
  (global-hi-lock-mode t)
#+END_SRC

Toggle a persistent highlight on current line.
#+BEGIN_SRC emacs-lisp
  (defun jms/find-overlays-specifying (prop pos)
    (let ((overlays (overlays-at pos))
          found)
      (while overlays
        (let ((overlay (car overlays)))
          (if (overlay-get overlay prop)
              (setq found (cons overlay found))))
        (setq overlays (cdr overlays)))
      found))

  (defun jms/highlight-or-dehighlight-line ()
    (interactive)
    (if (jms/find-overlays-specifying
         'line-highlight-overlay-marker
         (line-beginning-position))
        (remove-overlays (line-beginning-position) (+ 1 (line-end-position)))
      (let ((overlay-highlight (make-overlay
                                (line-beginning-position)
                                (+ 1 (line-end-position)))))
          (overlay-put overlay-highlight 'face '(:background "lightgreen"))
          (overlay-put overlay-highlight 'line-highlight-overlay-marker t))))

  (bind-key "C-c h" 'jms/highlight-or-dehighlight-line)
#+END_SRC

* Projects
** Projectile

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c p" project-prefix-map)
  (setq project-list-file
        (expand-file-name "projects"
                          jms/var-directory))
#+END_SRC

* Version control
** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-M-g" . magit-status)
           ("C-M-Ã¶" . magit-dispatch)
           ("C-M-m" . magit-file-dispatch)
           :map magit-blame-mode-map
           ("C-<return>" . jms/magit-blame-dig-deeper))
    :config
    (defun jms/magit-blame-dig-deeper ()
      (interactive)
      (magit-blame-visit-file)
      (magit-blame))

    (setq
       ;; Pop up the status window in the same buffer that it's invoked
       magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1

       ;; Signing
       magit-log-show-gpg-status t
       magit-commit-arguments '("--gpg-sign")

       ;; Prefer the "margin-format" style for magit-blame
       magit-blame-styles '((margin
                             (show-lines . nil)
                             (margin-format " %s%f" " %C %a%f" " %H%f")
                             (margin-width . 55)
                             (margin-face . magit-blame-margin)
                             (margin-body-face magit-blame-dimmed))
                            (headings
                             (heading-format . "%-20a %C %s\n"))
                            (highlight
                             (highlight-face . magit-blame-highlight))
                            (lines
                             (show-lines . t)
                             (show-message . t)))

       ;; Ask for name of new branch before parent when creating branch
       magit-branch-read-upstream-first nil

       ;; Set pushDefault when cloning
       magit-clone-set-remote-set.pushDefault t)
  
    ;; Add gpg signing option to rebase
    (transient-append-suffix 'magit-rebase "-A"
      '("-S" "Sign using gpg" "--gpg-sign=" magit-read-gpg-secret-key
        :class transient-option :allow-empty t))

    ;; Reenable inline editing of previous versions of file (automatically
    ;; triggers a rebase)
    (put 'magit-edit-line-commit 'disabled nil))

#+END_SRC

** sideline-blame

#+BEGIN_SRC emacs-lisp
  (use-package sideline-blame
    :ensure t
    :init (progn
            (add-to-list 'sideline-backends-left '(sideline-blame . down))
            (setq sideline-blame-datetime-format "%F "
                  sideline-backends-left-skip-current-line t
                  sideline-backends-right-skip-current-line t)

            (global-sideline-mode 1)))
#+END_SRC

** Ediff
Avoid creating new frames for ediff.

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

** Smerge
#+BEGIN_SRC emacs-lisp
  (setq smerge-command-prefix "\C-cd")
#+END_SRC

* Applications and utilities
** Compilation

#+BEGIN_SRC emacs-lisp
  (use-package multi-compile
    :ensure t)
#+END_SRC

** Bookmarks

#+BEGIN_SRC emacs-lisp
  (setq bookmark-default-file (expand-file-name "bookmarks" jms/var-directory))
#+END_SRC

** Docview

#+BEGIN_SRC emacs-lisp
  (setq doc-view-continuous t)
#+END_SRC

** Deft

#+BEGIN_SRC emacs-lisp
  (use-package deft
    :ensure t
    :bind ("C-c o" . deft)
    :init (setq deft-text-mode 'org-mode
                deft-default-extension "org"
                deft-directory (expand-file-name "deft"
                                                 jms/note-directory))
    :hook (deft-mode . (lambda ()
                         (remove-hook 'before-save-hook
                                      #'jms/trim-whitespace
                                      'local))))
#+END_SRC

** Image files

Use as an image viewer.
#+BEGIN_SRC emacs-lisp
  (auto-image-file-mode t)
#+END_SRC

** Eshell

#+BEGIN_SRC emacs-lisp
  (after 'esh-opt
    (setq eshell-directory-name (expand-file-name "eshell" jms/var-directory)))
#+END_SRC

** External

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "/usr/bin/firefox")
#+END_SRC

** Elisp Bug Hunter
This tool can be used when debugging the initialization of Emacs, in a
bisect-like fashion. To do this with tangled =.org= files, copy the
initialization from =init.el= up until the invocation of
=org-babel-load-file= and paste it at the top of =Jonne.el=. Then
comment out everything from =init.el= and add the following line:

#+BEGIN_EXAMPLE
  (load "~/.emacs.d/Jonne.el")
#+END_EXAMPLE

Then call =bug-hunter-init-file= and follow the on-screen instructions.

#+BEGIN_SRC emacs-lisp
  (use-package bug-hunter
    :ensure t)
#+END_SRC

* Language
** Language server-protocol

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :init (setq lsp-keymap-prefix "C-c z")
    :bind (:map lsp-mode-map
                ("C-c C-t" . lsp-describe-thing-at-point))
    :hook ((lsp-after-open . (lambda ()
                               (setq lsp-auto-configure t
                                     lsp-eldoc-render-all nil
                                     lsp-enable-xref t
                                     lsp-completion-enable t
                                     lsp-completion-provider :capf
                                     lsp-enable-file-watchers nil
                                     lsp-semantic-tokens-enable t
                                     lsp-enable-imenu t
                                     lsp-lens-enable t
                                     lsp-lens-place-position 'end-of-line
                                     lsp-imenu-show-container-name t
                                     lsp-signature-auto-activate t
                                     lsp-signature-render-documentation t)))
           (lsp-mode . lsp-ui-mode))
    :commands (lsp lsp-deferred))

  (use-package lsp-ui
    :ensure t
    :config (setq lsp-ui-doc-enable t
                  lsp-ui-doc-header t
                  lsp-ui-doc-border "gold1"
                  lsp-ui-doc-include-signature t
                  lsp-ui-doc-show-with-mouse nil
                  lsp-ui-doc-position 'bottom

                  lsp-ui-imenu-enable t
                  lsp-ui-imenu-kind-position 'top
                  lsp-ui-imenu-auto-refresh t
                  lsp-ui-imenu--custom-mode-line-format ""

                  lsp-ui-sideline-enable nil ;; Disabled since the font can't be resized due to a bug in Emacs 26-27
                  lsp-ui-sideline-ignore-duplicate t
                  lsp-ui-sideline-show-hover nil
                  lsp-ui-sideline-show-diagnostics t
                  lsp-ui-sideline-show-code-actions t
                  lsp-ui-sideline-show-update-mode 'point
                  lsp-ui-sideline-delay 0

                  lsp-ui-peek-enable t
                  lsp-ui-peek-always-show t
                  lsp-ui-peek-fontify 'on-demand
                  lsp-ui-peek-show-directory t
                  lsp-ui-peek-peek-height 30
                  lsp-ui-peek-list-width 50

                  lsp-ui-flycheck-list-position 'bottom)

    :bind (:map lsp-ui-mode-map
           ("M-." . lsp-ui-peek-find-definitions)
           ("M-?" . lsp-ui-peek-find-references)
           ("C-M-i" . lsp-ui-imenu)
           :map lsp-ui-peek-mode-map
           ("M-." . lsp-ui-peek--goto-xref-other-window)
           :map lsp-ui-imenu-mode-map
           ("M-n" . lsp-ui-imenu--next-kind)
           ("M-p" . lsp-ui-imenu--prev-kind))
    :commands lsp-ui-mode)

  (use-package helm-lsp
    :ensure t
    :commands helm-lsp-workspace-symbol)

  (use-package lsp-treemacs
    :ensure t
    :commands lsp-treemacs-errors-list)

  (use-package dap-mode
    :ensure t
    :hook ((lsp-mode . dap-mode)
           (lsp-mode . dap-ui-mode)))
#+END_SRC

** Agda

#+BEGIN_SRC emacs-lisp
  (ignore-errors
    (load-file (let ((coding-system-for-read 'utf-8))
                 (shell-command-to-string "agda-mode locate"))))

  (setq agda2-include-dirs
        (list "."
              (expand-file-name "~/.cabal/share/Agda-2.3.1/stdlib/src")))
#+END_SRC

** C

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook #'(lambda ()
                                    (c-toggle-auto-newline 1)
                                    (setq c-default-style "linux"
                                          c-basic-offset 4)))
#+END_SRC

** Dockerfile

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+END_SRC

** Erlang
#+BEGIN_SRC emacs-lisp
  (use-package erlang
    :ensure t
    :mode ("\\.[e\|h]rl" . erlang-mode)
    :init (require 'erlang-start))
#+END_SRC

** Haskell

Import utilities:
#+BEGIN_SRC emacs-lisp
  (setq jms/haskell-import-mapping
        '(("Data.Attoparsec.Char8" . "import qualified Data.Attoparsec.Char8 as Atto8\n")
          ("Data.Text" . "import qualified Data.Text as T\nimport Data.Text (Text)\n")
          ("Data.Text.Encoding" . "import qualified Data.Text.Encoding as T\n")
          ("Data.Text.Lazy.Encoding" . "import qualified Data.Text.Lazy.Encoding as LT\n")
          ("Data.Text.Lazy" . "import qualified Data.Text.Lazy as LT\n")
          ("Data.Text.IO" . "import qualified Data.Text.IO as T\n")
          ("Data.Text.Lazy.IO" . "import qualified Data.Text.IO as LT\n")
          ("Data.ByteString" . "import qualified Data.ByteString as S\nimport Data.ByteString (ByteString)\n")
          ("Data.ByteString.Char8" . "import qualified Data.ByteString.Char8 as S8\nimport Data.ByteString (ByteString)\n")
          ("Data.ByteString.Lazy" . "import qualified Data.ByteString.Lazy as L\n")
          ("Data.ByteString.Lazy.Builder" . "import qualified Data.ByteString.Builder as SB\n")
          ("Data.ByteString.Builder" . "import qualified Data.ByteString.Builder as SB\n")
          ("Data.ByteString.Lazy.Char8" . "import qualified Data.ByteString.Lazy.Char8 as L8\n")
          ("Data.Map" . "import qualified Data.Map.Strict as M\nimport Data.Map.Strict (Map)\n")
          ("Data.HashMap" . "import qualified Data.HashMap.Strict as HM\nimport Data.HashMap.Strict (HashMap)\n")
          ("Data.IntMap" . "import qualified Data.IntMap.Strict as IM\nimport Data.IntMap.Strict (IntMap)\n")
          ("Data.StrMap" . "import Data.StrMap as StrMap\nimport Data.StrMap (StrMap)\n")
          ("Data.Map.Strict" . "import qualified Data.Map.Strict as M\nimport Data.Map.Strict (Map)\n")
          ("Data.Set" . "import qualified Data.Set as Set\nimport Data.Set (Set)\n")
          ("Data.Vector" . "import qualified Data.Vector as V\nimport Data.Vector (Vector)\n")
          ("Data.Vector.Storable" . "import qualified Data.Vector.Storable as SV\nimport Data.Vector (Vector)\n")
          ("Data.List.NonEmpty" . "import qualified Data.List.NonEmpty as NE\nimport Data.List.NonEmpty (NonEmpty(..))\n")
          ("Data.Conduit.List" . "import qualified Data.Conduit.List as CL\n")
          ("Data.Conduit.Binary" . "import qualified Data.Conduit.Binary as CB\n")
          ("Data.Sequence" . "import qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\n")))

  (setq jms/haskell-imports-helm-source
        `((name . "*helm* Insert Haskell import")
          (candidates . ,jms/haskell-import-mapping)
          (action . (lambda (candidate)
                      (helm-marked-candidates)))))

  (defun jms/haskell-imports-helm ()
    (interactive)
    (insert
     (mapconcat 'identity
                (helm :sources '(jms/haskell-imports-helm-source))
                ",")))
#+END_SRC

Get some premade snippets:
#+BEGIN_SRC emacs-lisp
  (use-package haskell-snippets
    :ensure t)
#+END_SRC

Configure LSP to run HIE inside a Nix shell:
#+BEGIN_SRC emacs-lisp
  (defvar jms/haskell-shell-nix-absolute-path "."
    "The absolute path of the `shell.nix' file that sets up a nix
         shell for the Haskell environment to be used with `lsp-haskell'.")

  (defun jms/lsp-haskell-nix-wrapper-with (shell-nix argv)
    (let
        ((intercalate
          #'(lambda (sep l)
              (mapconcat 'identity l sep))))
      (append
       (list "nix-shell" "-I" ".")
       (list  "--command" (funcall intercalate " " argv))
       (list shell-nix))))

  (defun jms/lsp-haskell-nix-wrapper-absolute (argv)
    (jms/lsp-haskell-nix-wrapper-with jms/haskell-shell-nix-path argv))

  (defun jms/lsp-haskell-nix-wrapper-project-relative (argv)
    (jms/lsp-haskell-nix-wrapper-with
     (expand-file-name "shell.nix" (project-root (project-current))) argv))

  (defvar jms/lsp-haskell-server-alist
    '((none . ((path . nil)
               (wrapper-function . 'identity)))
      (hls-nix-absolute . ((path . "haskell-language-server-wrapper")
                           (wrapper-function . jms/lsp-haskell-nix-wrapper-absolute)))
      (hls-nix-project . ((path . "haskell-language-server-wrapper")
                             (wrapper-function . jms/lsp-haskell-nix-wrapper-project-relative)))))

  (use-package lsp-haskell
    :ensure t
    :hook ((haskell-mode . lsp)
           (haskell-literate-mode . lsp))
    :config
    (setq lsp-headerline-breadcrumb-enable nil ; https://github.com/emacs-lsp/lsp-mode/issues/2435#issuecomment-811194775
          lsp-haskell-hlint-on t
          lsp-haskell-diagnostics-on-change t
          lsp-haskell-completion-snippets-on t
          lsp-haskell-format-on-import-on t
          lsp-haskell-formatting-provider "stylish-haskell"
          lsp-haskell-server-args '("-d" "-l" "/tmp/hls.log")
          jms/lsp-haskell-server 'hls-nix-project
          lsp-haskell-server-path (map-nested-elt jms/lsp-haskell-server-alist
                                                  (list jms/lsp-haskell-server 'path))
          lsp-haskell-server-wrapper-function (map-nested-elt jms/lsp-haskell-server-alist
                                                              (list jms/lsp-haskell-server 'wrapper-function))))
#+END_SRC

In-editor building and repl tools:
#+BEGIN_SRC emacs-lisp
  ;; Fork of ghcid.el from https://github.com/lukasz-golebiewski/dotfiles/blob/master/emacs.d/extras/ghcid-nix.el
  (require 'ghcid-nix)
#+END_SRC

Finally, set up Haskell mode:
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :hook ((haskell-mode . haskell-indentation-mode)
           (haskell-mode . interactive-haskell-mode)
           (haskell-mode . subword-mode)
           (haskell-mode . haskell-doc-mode)
           (haskell-mode . company-mode))
    :mode ("\\.l?hs" . haskell-mode)
    :bind (:map haskell-mode-map
                ("C-c g" . haskell-hoogle)
                ("M-i" . jms/haskell-navigate-imports-toggle))
    :init (progn
            (setq haskell-stylish-on-save nil
                  haskell-process-suggest-remove-import-lines t
                  haskell-process-auto-import-loaded-modules t
                  haskell-process-log t)))

  (defun jms/haskell-navigate-imports-toggle ()
    (interactive)
    (if haskell-navigate-imports-start-point
        (progn
          (haskell-navigate-imports-return)
          (setq haskell-navigate-imports-start-point nil))
      (haskell-navigate-imports)))

  (after 'hydra
    (major-mode-hydra-define haskell-mode nil
      ("Imports and dependencies"
       (("o" jms/haskell-navigate-imports-toggle "imports")
        ("c" haskell-cabal-visit-file "cabal")
        ("d" haskell-cabal-add-dependency "add dependency to .cabal"))
       "Documentation"
       (("h" hoogle "hoogle"))
       "Editing"
       (("i" jms/haskell-imports-helm  "imports")
        ("y" yas-describe-tables "snippets")
        ("g" lsp-treemacs-errors-list "errors")
        ("e" lsp-iedit-highlights "iedit")))))

  (defun jms/haskell-cabal-indent-line ()
    "Indent current line according to subsection"
    (interactive)
    (cl-case (haskell-cabal-classify-line)
      (section-data
       (save-excursion
         (let ((indent (haskell-cabal-section-data-indent-column
                        (haskell-cabal-subsection))))
           (indent-line-to indent)
           (beginning-of-line)
           ;; (when (looking-at "[ ]*\\([ ]\\{2\\},[ ]*\\)")
           ;;   (replace-match ", " t t nil 1))
           )))
      (empty
       (indent-relative)))
    (haskell-cabal-forward-to-line-entry))

  (add-hook 'haskell-cabal-mode-hook (lambda () (setq-local indent-line-function 'jms/haskell-cabal-indent-line)))

  (after 'hydra
    (major-mode-hydra-define haskell-cabal-mode nil
      ("Module"
       (("c" haskell-cabal-find-or-create-source-file "find or create module"))
       "Cabal file"
       (("g" haskell-cabal-subsection-arrange-lines "arrange this section")))))
#+END_SRC

** Idris

#+BEGIN_SRC emacs-lisp
  (use-package idris-mode
    :ensure t)
#+END_SRC

** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :mode (("\\.json" . json-mode)
           ("\\.avsc" . json-mode))
    :init (setq js-indent-level 2))
#+END_SRC

** Lisp
Show documentation in the modeline.
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :init
    (progn
      (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
      (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
      (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
#+END_SRC

Use paredit.
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :bind (:map paredit-mode-map
                ("M-\"" . paredit-meta-doublequote)
                ("M-(" . paredit-wrap-round)
                ("M-s" . paredit-splice-sexp)
                ("M-r" . paredit-raise-sexp)
                ("M-S" . paredit-split-sexp)
                ("M-J" . paredit-join-sexp)
                ("C-(" . paredit-backward-slurp-sexp)
                ("C-)" . paredit-forward-slurp-sexp)
                ("C-M-(" . paredit-backward-barf-sexp)
                ("C-M-)" . paredit-forward-barf-sexp)
                ("C-M-<backspace>" . paredit-splice-sexp-killing-backward)
                ("C-M-<delete>" . paredit-splice-sexp-killing-forward)
                ("M-q" . paredit-reindent-defun))
    :config (progn
              ;; Unbind default bindings using the arrow keys to learn the
              ;; custom ones
              (unbind-key "C-M-<left>" paredit-mode-map)
              (unbind-key "C-M-<right>" paredit-mode-map)
              (unbind-key "C-<left>" paredit-mode-map)
              (unbind-key "C-<right>" paredit-mode-map)
              (unbind-key "M-<up>" paredit-mode-map)
              (unbind-key "M-<down>" paredit-mode-map))
    :init (progn
            (mapcar (lambda (hook) (add-hook hook #'enable-paredit-mode))
                    '(emacs-lisp-mode-hook
                      eval-expression-minibuffer-setup-hook
                      ielm-mode-hook
                      lisp-mode-hook
                      lisp-interaction-mode-hook
                      scheme-mode-hook))

            (after 'eldoc
              (eldoc-add-command
               'paredit-backward-delete
               'paredit-close-round))))
#+END_SRC

For easy tracing.
#+BEGIN_SRC emacs-lisp
  (defun p (arg)
    "Pretty print in new temporary buffer."
    (with-current-buffer (get-buffer-create "*log*")
      (display-buffer (current-buffer))
      (end-of-buffer)
      (insert (pp arg))
      (newline)))
#+END_SRC

** Latex

#+BEGIN_SRC emacs-lisp
  (use-package tex-site
    :ensure auctex
    :init
    (progn
      (setq TeX-auto-save t
            TeX-pare-self t
            TeX-PDF-mode t
            TeX-view-program-selection '((output-pdf "Zathura"))

            TeX-electric-sub-and-superscript t
            TeX-electric-math '("$" . "$")
            TeX-fold-math-spec-list '(("â§" ("\land"))
                                      ("â¨" ("\lor"))
                                      ("â" ("\implies"))
                                      ("â¢" ("\entailsc"))))
      (setq-default TeX-master nil)

      (setq reftex-plug-into-AUCTeX t
            reftex-label-alist
            '(("axiom"       ?a "ax:"  "~\\ref{%s}" nil ("axiom"   "ax.") -2)
              ("theorem"     ?h "thm:" "~\\ref{%s}" t ("theorem" "thm.") -3)
              ("restatable"  ?h "thm:" "~\\ref{%s}" t ("theorem" "thm.") -3)
              ("thmenum"     ?h "thm:" "~\\ref{%s}" t ("theorem" "thm.") -3)
              ("corollary"   ?h "cor:" "~\\ref{%s}" t ("corollary" "cor.") -3)
              ("proposition" ?h "prop:" "~\\ref{%s}" t ("proposition" "prop.") -3)
              ("lemma"       ?h "lemma:" "~\\ref{%s}" t ("lemma" "lemma.") -3))))
    :config (add-hook 'LaTeX-mode-hook #'jms/LaTeX-init))

  (defun jms/LaTeX-init ()
    (bind-key "C-c C-i" 'jms/TeX-insert-todo LaTeX-mode-map)

    (flyspell-mode)
    (flyspell-buffer)
    (LaTeX-math-mode)
    (TeX-source-correlate-mode)
    (turn-on-reftex)

    (LaTeX-add-environments
     '("axiom" LaTeX-env-label)
     '("theorem" LaTeX-env-label)
     '("corollary" LaTeX-env-label)
     '("proposition" LaTeX-env-label)
     '("lemma" LaTeX-env-label))

    (eval-after-load "tex"
      '(setcdr (assoc "LaTeX" TeX-command-list)
               '("%`%l%(mode) -shell-escape%' %t"
                 TeX-run-TeX nil (latex-mode doctex-mode) :help "Run LaTeX")))

    ;; Use preview-latex to compile parts of the file to inline images.
    ;; Keys:  C-c C-p C-b       - preview buffer
    ;;        C-c C-p C-c C-b   - unpreview buffer
    ;;        C-c C-p C-p       - preview at point
    ;; (load "preview-latex.el" nil t t)

    ;; Use outline mode to fold sections (and environments).
    ;; Keys:  F10                 - outline-cycle
    ;; Note that I use outline-magic rather than the default behaviour.
    (outline-minor-mode 1)

    ;; Use TeX-fold-mode to fold macros, comments and environments.
    ;; Keys: C-c C-o C-f     - toggle folding mode
    ;;       C-c C-o C-b     - fold buffer
    ;;       C-c C-o b       - unfold buffer
    ;;       C-c C-o C-o     - fold do what I want
    (TeX-fold-mode 1)
    (TeX-fold-buffer))

  (defun jms/LaTeX-align-and-newline ()
    "Automatically insert \\ and & as needed within an align or
  align* environment."
    (interactive "*")
    (if (member (LaTeX-current-environment) '("align" "align*"))
        (progn
          (insert "\\\\")
          (newline-and-indent)
          (insert "&"))
      (newline-and-indent)))

  (defvar jms/TeX-todo-macros-alist
    '(("todo"    . ("todo" . "itodo"))
      ("new"     . ("todonew" . "itodonew"))
      ("ref"     . ("todoref" . "itodoref"))
      ("clarify" . ("todoclarify" . "itodoclarify"))
      ("unsure"  . ("todounsure" . "itodounsure"))
      ("rewrite" . ("todorewrite" . "itodorewrite"))
      ("style"   . ("todostyle" . "itodostyle")))

    "A mapping of LaTeX \"todo\" macro names.

  Containins pairs (NAME . (MACRO . IMACRO)) where NAME is a
  mnemonic for use with `jms/TeX-insert-macro' and MACRO and IMACRO
  are names of the \"stand-alone\" and inline versions of the todo
  macro.

  For use with the todo LaTeX package and my stylesheet.")

  (defun jms/TeX-insert-todo (category &optional inline)
    "Insert a \"todo\" macro in the margin.

  If the universal argument is given, insert the inline version instead."
    (interactive
     (let ((categories (mapcar #'car jms/TeX-todo-macros-alist)))
       (list (ido-completing-read "Todo category: " categories)
             (consp current-prefix-arg))))
    (progn
      (let ((macro (cdr-safe (assoc category jms/TeX-todo-macros-alist))))
        (if macro
            (TeX-insert-macro (if inline
                                  (cdr macro)
                                (car macro)))))))

  (defun jms/synctex-sync-command (file line)
    (interactive)
    (progn
      (find-file file)
      (goto-line line)))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    ;; Pandoc's markdown_github format includes the hard_line_breaks
    ;; extension by default, so remove it with -hard_line_breaks
    :init (setq markdown-command "pandoc -f markdown_github-hard_line_breaks")
    :mode ("\\.md\\'" . gfm-mode))
#+END_SRC

** Nginx

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode
    :ensure t)
#+END_SRC

** Nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :ensure t
    :mode ("\\.nix\\'" "\\.nix.in\'"))
#+END_SRC

** Org

#+BEGIN_SRC emacs-lisp
  (setq org-completion-use-ido t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c b" 'org-iswitchb)
#+END_SRC

Use speed commands to avoid arrow keys. Press =?= on the beginning
of a headline (before the stars) to show a help text.
#+BEGIN_SRC emacs-lisp
  (setq org-use-speed-commands t)
#+END_SRC

Use org-indent-mode.
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t
        ; Actually insert indentation under headings etc into the
        ; plain-text file instead of just displaying it that way.
        org-indent-mode-turns-off-org-adapt-indentation nil)
#+END_SRC

*** Capturing
#+BEGIN_SRC emacs-lisp
  (bind-key "C-M-r" 'org-capture)
  (setappendq org-capture-templates
              `(("t" "Todo" entry
                 (file+headline ,(expand-file-name "todo.org"
                                                   jms/note-directory)
                                "Tasks")
                 "* TODO %?\n %i\nAdded: %U\n%?")
                ("n" "Notes" entry
                 (file+headline ,(expand-file-name "notes.org"
                                                   jms/note-directory)
                                "Notes")
                 "* %u %?")))
#+END_SRC

*** Browser bookmarks
Store browser's bookmarks in an ~.org~ file (using ~org-protocol~).
#+BEGIN_SRC emacs-lisp
  (setappendq org-capture-templates
              `(("p" "Website with selection" entry
                 (file+headline ,(expand-file-name "bookmarks/bookmarks.org"
                                                   jms/note-directory)
                                "Inbox")
                 "* %c\n  :DATE: %u\n  #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n"
                 :immediate-finish
                 :kill-buffer)
                ("L" "Website" entry
                 (file+headline ,(expand-file-name "bookmarks/bookmarks.org"
                                                   jms/note-directory)
                                "Inbox")
                 "* %c\n  :DATE: %u\n"
                 :immediate-finish
                 :kill-buffer)))

  (use-package org-protocol)
#+END_SRC

Apparently, if ~org-capture~ is called with a universal prefix it
opens the capture file without adding anything, so we could also
use ~C-u M-x org-capture RET w~ to go to the bookmarks file.
#+BEGIN_SRC emacs-lisp
  (defun find-browser-bookmarks ()
    "Open the browser bookmark file."
    (interactive)
    (find-file (expand-file-name "bookmarks/bookmarks.org"
                                 jms/note-directory)))
#+END_SRC

*** Babel
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

Set up the languages that should support tangling/execution.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((emacs-lisp . t)
                                 (python . t)
                                 (matlab . t)
                                 (R . t)))
#+END_SRC

Typing the ~#+BEGIN_SRC <lang>~ things manually is tedious.
#+BEGIN_SRC emacs-lisp
  (defun jms/org-insert-name-keyword (name)
    "Query for `NAME' and insert '#+NAME: NAME' at point."
    (interactive "sName: ")
    (progn
      (newline-and-indent)
      (insert (format "#+NAME: %s\n" name))))

  (defun jms/org-insert-src-block (src-code-type &optional prefix)
    "Insert a `SRC-CODE-TYPE' type source code block in org-mode.

  If called with a prefix argument, also query for a name and
  insert a named code block. If called with a double prefix, make
  the code block support noweb references."
    (interactive
     (let ((src-code-types
            '("emacs-lisp" "python" "C" "sh" "java" "js" "clojure" "C++" "css"
              "calc" "asymptote" "dot" "gnuplot" "ledger" "lilypond" "mscgen"
              "octave" "oz" "plantuml" "R" "sass" "screen" "sql" "awk" "ditaa"
              "haskell" "latex" "lisp" "matlab" "ocaml" "org" "perl" "ruby"
              "scheme" "sqlite")))
       (list (ido-completing-read "Source code type: " src-code-types)
             (if (consp current-prefix-arg)
                 (car current-prefix-arg)
               0))))
    (let ((indent (save-excursion
                    (indent-according-to-mode)
                    (current-column))))
      (if (not (= prefix 4))
          (newline-and-indent)
        (call-interactively 'jms/org-insert-name-keyword)
        (indent-to indent))

      (insert (format "#+BEGIN_SRC %s" src-code-type))
      (when (= prefix 16)
          (insert " :noweb yes"))

      (insert "\n\n")
      (indent-to indent)
      (insert "#+END_SRC\n")

      (previous-line 2)

      (indent-according-to-mode)

      (org-edit-src-code)))

  (bind-key "C-c s i" 'jms/org-insert-src-block org-mode-map)
#+END_SRC

Split a source code block intelligently.
#+BEGIN_SRC emacs-lisp
  (defun jms/org-split-source-block ()
    "End the source code block at point and open a new one with the
  same header."
    (interactive)
    (let* ((beg (org-babel-where-is-src-block-head))
           (end (save-excursion (goto-char beg) (line-end-position)))
           (header (buffer-substring beg end))
           (indent (save-excursion
                     (goto-char beg)
                     (current-column))))
      (insert "\n")
      (indent-to indent)
      (insert "#+END_SRC")
      (insert "\n\n")
      (insert header)
      (previous-line)
      (indent-according-to-mode)))

  (bind-key "M-S" 'jms/org-split-source-block org-mode-map)
#+END_SRC

** PKGBUILD

#+BEGIN_SRC emacs-lisp
  (use-package pkgbuild-mode
    :ensure t
    :mode (("/PKGBUILD$" . pkgbuild-mode)))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (use-package lsp-python-ms
    :ensure t
    :init (setq lsp-python-ms-auto-install-server t)
    :hook (python-mode . (lambda ()
                            (require 'lsp-python-ms)
                            (lsp))))
#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t

    :mode (("\\.rs\\'" . rust-mode))

    :bind (("C-c C-c" . multi-compile-run))

    :init
    (progn
      ;; Source code nagigation and completion
      (use-package racer
        :ensure t
        :init
        (progn
          (setq racer-cmd "/usr/bin/racer")
          (setq racer-rust-src-path "/usr/src/rust/src")

          (add-hook 'racer-mode-hook #'eldoc-mode)))

      (use-package cargo
        :ensure t)

      (use-package flycheck-rust
        :ensure t
        :config
        (after 'flycheck
          (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))

      (after 'multi-compile
        (add-to-list 'multi-compile-alist
                     '(rust-mode . (("rust-debug" . "cargo run")
                                    ("rust-release" . "cargo run --release")
                                    ("rust-test" . "cargo test"))))))

    :config
    (progn
      (setq rust-indent-method-chain t)
      (add-hook 'rust-mode-hook #'jms/rust-init )))

  (defun jms/rust-init ()
    (after 'flycheck
      (flycheck-mode))

    (add-hook 'before-save-hook #'rust-format-buffer nil t)

    (cargo-minor-mode)

    (racer-mode))
#+END_SRC

** SASS

#+BEGIN_SRC emacs-lisp
  (use-package sass-mode
    :ensure t)
#+END_SRC

** Systemd

For systemd =.service=-files and similar.
#+BEGIN_SRC emacs-lisp
  (use-package systemd
    :ensure t
    :disabled t ; broken (2023-09-05)
    )
#+END_SRC

** Yaml

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml$" . yaml-mode) ("\\.yaml$" . yaml-mode)))
#+END_SRC

* Appearance
** Remove toolbars and other nonsense
#+BEGIN_SRC emacs-lisp
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

Never use dialog boxes.
#+BEGIN_SRC emacs-lisp
  (setq use-dialog-box nil)
#+END_SRC

** Change cursor color according to mode (overwrite, insert, read-only)
#+BEGIN_SRC emacs-lisp
  (setq jms/set-cursor-color-color "")
  (setq jms/set-cursor-color-buffer "")
  (defun jms/set-cursor-color-according-to-mode ()
    "change cursor color according to some minor modes."
    ;; set-cursor-color is somewhat costly, so we only call it when needed:
    (let ((color
           (if buffer-read-only "black"
             (if overwrite-mode "red"
               "blue"))))
      (unless (and
               (string= color jms/set-cursor-color-color)
               (string= (buffer-name) jms/set-cursor-color-buffer))
        (set-cursor-color (setq jms/set-cursor-color-color color))
        (setq jms/set-cursor-color-buffer (buffer-name)))))
  (add-hook 'post-command-hook 'jms/set-cursor-color-according-to-mode)
#+END_SRC

** Print file name in title
#+BEGIN_SRC emacs-lisp
  (setq frame-title-format
    '("" invocation-name ": "(:eval (if (buffer-file-name)
                  (abbreviate-file-name (buffer-file-name))
                    "%b"))))
#+END_SRC

** Highlight the current line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 1)
#+END_SRC

** Show matching parentheses

Customize ~show-paren-mode~ to highlight whole expressions and loosen
the conditions for when highlighting is done. Also show some context
in the echo area if the whole expression isn't on screen at once.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'expression
        show-paren-when-point-inside-paren t
        show-paren-when-point-in-periphery t
        show-paren-context-when-offscreen t)
#+END_SRC

** Color parentheses by depth

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Fringe

#+BEGIN_SRC emacs-lisp
  (setq fringe-mode 10)
  (set-fringe-mode fringe-mode)
  #+END_SRC

Show the git status of every line in the fringe.
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :ensure t
    :hook (magit-post-refresh . diff-hl-magit-post-refresh)
    :config (progn
              (global-diff-hl-mode)
              (diff-hl-flydiff-mode)))
#+END_SRC

** Appearance
*** Font
Customize the font by searching through available fonts on the system.
We have to jump through some hoops to ensure that the function is
deferred until the graphical session has started. Otherwise,
=find-font= will fail to return any matches:
#+BEGIN_SRC emacs-lisp
  (defun jms/set-new-frame-font-oneshot ()
    (let ((font-available-p (lambda (font)
                              (find-font (font-spec :name font)))))
      (cond
       ((funcall font-available-p "JuliaMono Frozen")
        (set-face-attribute 'default nil :font "JuliaMono Frozen-14"))
       ((funcall font-available-p "Dejavu Sans Mono")
        (set-face-attribute 'default nil :font "Dejavu Sans Mono-14"))))

    (remove-hook 'server-after-make-frame-hook #'jms/set-new-frame-font-oneshot))

  (if (daemonp)
      (add-hook 'server-after-make-frame-hook
                #'jms/set-new-frame-font-oneshot)
    (jms/set-new-frame-font-oneshot))
  #+END_SRC

Use ligatures (no sensible way to opt in to everything, sadly):
#+BEGIN_SRC emacs-lisp
  (use-package ligature
    :ensure t

    :config
    (let ((ligs '("->" "=>" "|>" "<|" "::" "<--" "-->" "<-->" "==" "===" "====" "<!--")))
            (ligature-set-ligatures 'prog-mode ligs)
            (ligature-set-ligatures 'org-mode ligs))
    (global-ligature-mode t))
#+END_SRC

*** Theme
The base theme is moe-light:
#+BEGIN_SRC emacs-lisp
  (use-package moe-theme
    :ensure t
    :config (enable-theme 'moe-light))
#+END_SRC

But we override some parts of the theme to my liking:
#+BEGIN_SRC emacs-lisp
  (load-theme 'ljhms-moe-light-tweaks t nil)
#+END_SRC

*** Modeline

The modeline has significant tweaks to the point where I use none of
the default settings from moe-light. This theme also sets a custom
=mode-line-format=. It it throws away e.g. the minor modes, rather
than using diminish, since I dislike the clutter:
#+BEGIN_SRC emacs-lisp
  (which-function-mode 1)
  (setq which-func-unknown "â¤")

  (load-theme 'ljhms-modeline t nil)
#+END_SRC

* Apply machine-local settings
These should ideally only be limited to work-specidfic things that
cannot be shared on Github.

#+BEGIN_SRC emacs-lisp
  (when (file-exists-p jms/emacs-init-org-file-local)
    (org-babel-load-file jms/emacs-init-org-file-local))
#+END_SRC
